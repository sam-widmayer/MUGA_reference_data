---
title: "Reference Data QC: MUGA"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_depth: 3
    code_folding: hide
---

# MUGA Annotations

```{r setup, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
# library(tidyverse)
# ^ this if running locally
require(dplyr)
require(tidyr)
require(stringr)
# ^ these if running on sumner
library(data.table)
library(purrr)
library(furrr)
library(qtl2)
library(magrittr)
library(DT)
library(plotly)
library(progress)
library(ape)
library(RColorBrewer)
library(tictoc)
library(furrr)
library(vroom)
future::plan(multicore)
today <- format(Sys.Date(), format="%Y%m%d")
QCtheme <- theme_bw() + 
  theme(panel.grid = element_blank(),
        axis.text = element_text(colour = "black"),
        axis.title = element_text(colour = "black"))

###########################################
# Function designed to recode genotype calls from letter format (i.e. G1, HET, or G2) to numeric format (i.e. 0, 1, 2)
# Inputs:
# x = Column of genotype values
# Outputs:
# Numeric vector of recoded genotypes
###########################################
recodeCalls <- function(x){
  y <- factor(c(as.matrix(x)))
  levels(y)[which(levels(y) == "H")] <- 1
  levels(y)[which(levels(y) != 1)] <- c(0,2)
  return(as.numeric(as.character(y)))
}

###########################################
# Function to form F1 genotypes from founder consensus genotypes
# Inputs:
# x = Row of genotype values
# Outputs:
# Numeric vector of single letter genotypes
###########################################
callGeno <- function(x){
  
  # Compare genotypes from both strains
      if(c(x[[2]] == x[[3]])){
        #If they are the same, keep the first value
        predicted.geno <- x[[2]]
      } else {
        #If they are different, code as a het
        predicted.geno <- "H"
      }
      return(predicted.geno)
}

###########################################
# Function used in the loop which forms founder consensus genotypes prior to background QC
# Inputs:
# mk = marker
# data = genotype data for each founder sample
# f = founder strain
# Outputs:
# data frame with 1 row with columns: marker; consensus genotype for founder strain f 
###########################################
removeExtremeInts <- function(mk, data, f){
    
    # Calculate summary statistics for probe intensities
    sd.x.int <- sd(data$X)
    sd.y.int <- sd(data$Y)
    mean.x.int <- mean(data$X)
    mean.y.int <- mean(data$Y)

    data %>%
      # With a prior expectation provided by an "N" call, determine whether probe intensities are unusual and 
      # flag samples that meet both criteria
      dplyr::mutate(x.ex = dplyr::if_else(X > (mean.x.int + sd.x.int) | X > (mean.x.int + sd.x.int), true = "EX", false = ""),
                    y.ex = dplyr::if_else(Y > (mean.y.int + sd.y.int) | X > (mean.y.int + sd.y.int), true = "EX", false = ""),
                    flag = dplyr::if_else(genotype == "N" & (x.ex == "EX" | y.ex == "EX"), true = "FLAG", false = "")) %>%
      dplyr::filter(flag != "FLAG") %>%
      dplyr::mutate(marker = mk) %>%
      dplyr::distinct(marker,genotype) %>%
      dplyr::select(marker,genotype) %>%
      `colnames<-`(c("marker",f))
  }

###########################################
# Function to form F1 genotypes from founder consensus genotypes
# Inputs:
# x = Row of genotype values
# Outputs:
# Numeric vector of single letter genotypes
###########################################
callHemiGeno <- function(x){
    # Mitochondria comes from dam
    predicted.geno <- x[[2]]
    return(predicted.geno)
}

###########################################
# Function to call expected Chr X genotypes for F1 samples based on sample sex and calculate concordance between expected and observed F1 genotypes
# Inputs:
# sp = Sample name
# isex = Sample sex
# data = Sample genotype data
# cross = F1 genotype predictions 
# chrX_markers = data frame of chromosome X marker names

# Outputs:
# geno_comp_Xrecoded = data frame of sample genotypes and concordance with expected F1 genotypes
###########################################
callXGeno <- function(sp, isex, data, cross, chrX_markers){
    
    if(isex == "m"){
      
      # Filter expected genotypes to just X chromosome markers
      male_F1 <- cross %>%
        dplyr::filter(marker %in% chrX_markers$marker) %>%
        dplyr::ungroup()
      # Use callHemiGeno function to assign maternal genotypes as expected X genotypes in males
      male_F1$predicted_genotypes <- apply(male_F1, 1, callHemiGeno)
      male_recoded_cross <- cross %>%
        dplyr::filter(!marker %in% chrX_markers$marker) %>%
        dplyr::bind_rows(.,male_F1)
      
      # Calculate the concordance between genotypes using hemizygous X calls
      geno_comp_Xrecoded <- data %>%
        dplyr::inner_join(.,male_recoded_cross %>%
                                             dplyr::ungroup() %>%
                            dplyr::select(marker,predicted_genotypes)) %>% 
        dplyr::mutate(matching_genos = dplyr::if_else(genotype == predicted_genotypes,
                                                      true = "MATCH",
                                                      false = "NO MATCH"),
                      alt_chr = dplyr::case_when(chr == "M" ~ "M",
                                                 chr == "X" ~ "X",
                                                 chr == "Y" ~ "Y",
                                                 is.na(chr) ~ "Other",
                                                 TRUE ~ "Autosome"),
                      alt_chr = as.factor(alt_chr),
                      sample = sp,
                      predicted.sex = isex)
      
    } else {
      
      # Calculate the concordance between genotypes using diploid X calls
      geno_comp_Xrecoded <- data %>%
        dplyr::inner_join(.,cross %>%
                            dplyr::ungroup() %>%
                            dplyr::select(marker,predicted_genotypes)) %>%
        dplyr::mutate(matching_genos = dplyr::if_else(genotype == predicted_genotypes,
                                                      true = "MATCH",
                                                      false = "NO MATCH"),
                      alt_chr = dplyr::case_when(chr == "M" ~ "M",
                                                 chr == "X" ~ "X",
                                                 chr == "Y" ~ "Y",
                                                 is.na(chr) ~ "Other",
                                                 TRUE ~ "Autosome"),
                      alt_chr = as.factor(alt_chr),
                      sample = sp,
                      predicted.sex = isex)
    }
    
    return(geno_comp_Xrecoded)
}

###########################################
# Function to form reference sample genotypes for comparison
# Inputs:
# Consensus genotypes for dam strain
# Consensus genotypes for sire strain

# Outputs:
# Numeric vector of recoded genotypes
###########################################
founder_background_QC <- function(dam, sire){
  
  # Extract strain names from genotype objects\
  dam.df <- data.frame(dam)
  sire.df <- data.frame(sire)
  dam_strain <- gsub(colnames(dam.df)[2], pattern = "X", replacement = "") %>% gsub(., pattern = "[.]", replacement =  "/")
  sire_strain <- gsub(colnames(sire.df)[2], pattern = "X", replacement = "") %>% gsub(., pattern = "[.]", replacement =  "/")
  
  if(dam_strain == sire_strain){
    print(paste0("Running QC: ", dam_strain))  
  } else {
    print(paste0("Running QC: (", dam_strain, "x", sire_strain, ")F1"))  
  }
  
  # Identify samples from supplied strains
  maternalF1s <- final_founder_samples %>%
    dplyr::filter(dam == dam_strain,
                  sire == sire_strain) %>%
    dplyr::mutate(sire = as.factor(sire),
                  dam = as.factor(dam))
  
  if(nrow(maternalF1s) == 0){
    # Some crosses don't exist in reference data, can't be QC'd
    return("No samples from this cross; skipping")
  } else {
  
  # Remove consensus genotypes for each strains that are N's
  mom <- dam.df[which(!dam.df[,2] %in% c("H","N")),]
  dad <- sire.df[which(!sire.df[,2] %in% c("H","N")),]
  
  # Form a hypothetical F1 hybrid by combining genotypes from markers that exist in both strains
  if(dam_strain == sire_strain){
    cross <- dplyr::inner_join(mom[complete.cases(mom),],dad[complete.cases(dad),], "marker")
  } else {
    cross <- dplyr::inner_join(mom[complete.cases(mom),],dad[complete.cases(dad),])
  }
  
  
  # Form a list of mitochondrial markers
  alt_chr_M <- genos.flagged %>%
    dplyr::filter(chr %in% c("M")) %>%
    dplyr::distinct(marker)
  
  # Form a list of Chr X markers
  alt_chr_X <- genos.flagged %>%
    dplyr::filter(chr %in% c("X")) %>%
    dplyr::distinct(marker)
  
  # Predict F1 genotypes from consensus genotypes for each strain
  predicted.genotypes <- apply(cross, 1, FUN = callGeno)
  cross$predicted_genotypes <- predicted.genotypes
  
  # Filter the artificial F1 hybrid genotype calls down to mitochondrial markers
  mito_cross <- alt_chr_M %>% 
    dplyr::left_join(., cross)
  # Assign maternal mitochondrial genotype to predicted cross instead of hets where strains have different mitotypes
  mito_cross$predicted_genotypes <- apply(mito_cross, 1, FUN = callHemiGeno)
  cross_mitorecoded <- cross %>%
    dplyr::filter(!marker %in% alt_chr_M$marker) %>%
    dplyr::bind_rows(.,mito_cross)

  # Gather genotypes for F1 samples and remove bad markers
  sample_genos <- maternalF1s %>%
    dplyr::right_join(genos.flagged,.,by = "sample") %>%
    dplyr::filter(marker %in% mom$marker, 
                  genotype != "N") %>%
    dplyr::distinct(marker, sample, genotype, .keep_all = TRUE) %>%
    dplyr::filter(marker_flag != "FLAG")
  
  # Nest genotypes by sample and sex to prepare for calling Chr X genotypes
  nested_samples <- sample_genos %>%
    dplyr::group_by(sample, predicted.sex) %>%
    tidyr::nest()
  
  # Create a list of mitochondrial and X genotypes to be supplied to the callXGeno function
  cross_mitorecoded_list <- list()
  for(i in 1:length(nested_samples$data)){
    cross_mitorecoded_list[[i]] <- cross_mitorecoded
  }
  alt_chr_X_list <- list()
  for(i in 1:length(nested_samples$data)){
    alt_chr_X_list[[i]] <- alt_chr_X
  }
  
  # Recode X genotypes to match expectations for male and female samples and form a dataframe of sample genotypes (and concordance status)
  final_geno_comp <- purrr::pmap(.l = list(nested_samples$sample,
                                           nested_samples$predicted.sex,
                                           nested_samples$data,
                                           cross_mitorecoded_list,
                                           alt_chr_X_list), 
                                 .f = callXGeno) %>% 
    Reduce(rbind,.)
  
  # Tabulate the percentage of concordant genotypes between theoretical and actual F1 samples
  geno_comp_summary <- final_geno_comp %>%
    dplyr::group_by(sample, predicted.sex, alt_chr, matching_genos) %>%
    dplyr::count() %>%
    tidyr::pivot_wider(names_from = matching_genos, values_from = n) %>%
    dplyr::mutate(dam = dam_strain, 
                  sire = sire_strain)
  
  # Return genotypes and their summary statistics
  return(list(final_geno_comp,geno_comp_summary))
  }
}

###########################################
# Function to quickly pull strain names from non-founder samples
# Inputs:
# Sample IDs

# Outputs:
# Character vector of strains
###########################################
findStrain <- function(x){
  
  # Decompose strain from mouse ID for males
  m_strains <- strsplit(x, split = "m")[[1]]
  
  # If the string was actually split using "m" the sample was male
  if(TRUE %in% str_detect(m_strains, pattern = "X12")){
    
    # If there was a 129 or similar mouse with an m in the strain name, some collapsing needs to occur
    X129_strains <- paste(strsplit(x, split = "m")[[1]][[1]], sep = "m", collapse = "m")
    return(X129_strains)
      
  } else if(length(m_strains) == 1){
    
    f_strains <- strsplit(x, split = "f")[[1]][[1]] 
    return(f_strains)
  } else {
    
    return(m_strains[[1]][[1]])
  }
      
}

###########################################
# Function to re-derive founder consensus genotypes for founders that are missing consensus calls due to one or a few bad calls
# Inputs:
# mk = marker name
# data = data frame with founder strain samples, intensities, individual sample genotype calls , and existing consensus genotype calls

# Outputs:
# 1) Consensus genotype calls for each founder strain
# 2) Wide genotype table for all founder samples
# 3) Data frame with recoded consensus genotypes for each samples with intensity data and strain names, as well as a flag for whether the sample contributed to a recoded consensus genotype
###########################################

findConsensusGenotypes <- function(mk, data){
  
  # Examples use mk = "UNC13666424"
  
  # Annotate sample genotype data with summed intensities as a heuristic and filter to sample genotypes assigned a real genotype
  call_filtered_data <- data %>%
    dplyr::mutate(sum_int = X+Y) %>%
    dplyr::filter(sample_genotype %in% c("A","C","T","G","H"))
# Example
# Note: NOD sample is missing a consensus genotype at this marker
#    strain        consensus_genotype sample                  X     Y theta sample_genotype sum_int
#    <chr>         <chr>              <chr>               <dbl> <dbl> <chr> <chr>             <dbl>
#  1 "A/J"         C                  A/J (f)             0.075 0.837 0.943 C                 0.912
#  2 "A/J"         C                  A/Jm111 (m)         0.086 0.84  0.935 C                 0.926
#  3 "C57BL/6J"    T                  C57BL/6J (f)        0.568 0.234 0.249 T                 0.802
#  4 "129S1/SvImJ" C                  129S1/SvImJ (f)     0.127 0.805 0.901 C                 0.932
#  5 "129S1/SvImJ" C                  129S1/SvImJm212 (m) 0.117 0.918 0.919 C                 1.04 
#  6 "NOD/ShiLtJ"  NA                 NOD/LtJ (f)         0.121 0.804 0.905 C                 0.925
#  7 "NZO/HlLtJ "  C                  NZO/HlLtJ (f)       0.036 0.812 0.972 C                 0.848
#  8 "NZO/HlLtJ "  C                  NZO/HlLtJm51 (m)    0.045 0.809 0.964 C                 0.854
#  9 "CAST/EiJ"    C                  CAST/EiJ (f)        0.051 0.817 0.96  C                 0.868
# 10 "CAST/EiJ"    C                  CAST/EiJm42 (m)     0.07  0.792 0.944 C                 0.862
# 11 "PWK/PhJ"     C                  PWK/PhJ (f)         0.056 0.71  0.95  C                 0.766
# 12 "PWK/PhJ"     C                  PWK/PhJm175 (m)     0.075 0.795 0.94  C                 0.87 
# 13 "WSB/EiJ"     T                  WSB/EiJ (f)         0.576 0.269 0.278 T                 0.845
  
  # Derive a lower bound by which to identify true N calls using the intensity data
  real_N_cutoff <- quantile(call_filtered_data$sum_int, probs = seq(0,1,0.05))[[2]]
  # Use this threshold to identify potential miscalls and remove them in order to recode samples without consensus calls
  filtered_data <- call_filtered_data %>%
    dplyr::mutate(test = if_else(sum_int < real_N_cutoff & is.na(consensus_genotype), true = "miscall", false = "")) %>%
    dplyr::filter(test != "miscall")
  
  # Determine the number of clusters to use for k-means clustering of intensity values;
  # If the previous steps have succeeded, there should be one or two real genotypes segregating and samples can be re-called by k-means
  n_genos <- length(unique(filtered_data$sample_genotype[which(filtered_data$sample_genotype %in% c("A","C","T","G","H"))]))
  ints_for_kmeans <- filtered_data %>%
    dplyr::select(X, Y)
  consensus_geno_clusters <- kmeans(ints_for_kmeans, centers = n_genos)$cluster
  
  # Joining each sample's cluster assignment to the sample intensity metrics
  genos.k.means <- filtered_data %>%
    dplyr::mutate(clust = as.factor(consensus_geno_clusters))
  
  # Create a join table to pair up clusters with genotypes
  gens_by_cluster_tab <- genos.k.means %>%
    dplyr::group_by(sample_genotype, consensus_genotype, clust) %>%
    dplyr::count() %>%
    arrange(-n)
# Example:
#   sample_genotype consensus_genotype clust     n
#   <chr>           <chr>              <fct> <int>
# 1 C               C                  1        10
# 2 T               T                  2         2
# 3 C               NA                 1         1
  
  # Filter the join table to hopefully have a 1:1 relationship between consensus genotypes and clusters
  top_clusters <- gens_by_cluster_tab %>%
    dplyr::filter(!is.na(consensus_genotype)) %>%
    dplyr::ungroup() %>%
    dplyr::distinct(sample_genotype, clust) %>%
    dplyr::rename(consensus_genotype = sample_genotype)
  # Example:
#   consensus_genotype clust
#   <chr>              <fct>
# 1 C                  1    
# 2 T                  2    

  # Samples are then recoded according to the k-means assigned genotypes and noted whether a consensus was re-assigned
  unknown_before <- filtered_data %>%
    dplyr::filter(is.na(consensus_genotype))
  recoded_consensus_genotypes <- genos.k.means %>%
    dplyr::select(-consensus_genotype) %>%
    dplyr::left_join(.,top_clusters, by = "clust") %>%
    dplyr::mutate(marker = mk) %>% 
    dplyr::mutate(recoded = dplyr::if_else(sample %in% unknown_before$sample, true = "RECODED", false = "")) %>%
    dplyr::select(-clust)
  # Example: recoded_consensus_genotypes[20:30,]
#    strain        sample                  X     Y theta sample_genotype sum_int test  consensus_genotype marker     recoded
#    <chr>         <chr>               <dbl> <dbl> <chr> <chr>             <dbl> <chr> <chr>              <chr>      <chr>  
#  1 "A/J"         A/J (f)             0.075 0.837 0.943 C                 0.912 ""    C                  UNC_rs510… ""     
#  2 "A/J"         A/Jm111 (m)         0.086 0.84  0.935 C                 0.926 ""    C                  UNC_rs510… ""     
#  3 "C57BL/6J"    C57BL/6J (f)        0.568 0.234 0.249 T                 0.802 ""    T                  UNC_rs510… ""     
#  4 "129S1/SvImJ" 129S1/SvImJ (f)     0.127 0.805 0.901 C                 0.932 ""    C                  UNC_rs510… ""     
#  5 "129S1/SvImJ" 129S1/SvImJm212 (m) 0.117 0.918 0.919 C                 1.04  ""    C                  UNC_rs510… ""     
#  6 "NOD/ShiLtJ"  NOD/LtJ (f)         0.121 0.804 0.905 C                 0.925 ""    C                  UNC_rs510… "RECOD…
#  7 "NZO/HlLtJ "  NZO/HlLtJ (f)       0.036 0.812 0.972 C                 0.848 ""    C                  UNC_rs510… ""     
#  8 "NZO/HlLtJ "  NZO/HlLtJm51 (m)    0.045 0.809 0.964 C                 0.854 ""    C                  UNC_rs510… ""     
#  9 "CAST/EiJ"    CAST/EiJ (f)        0.051 0.817 0.96  C                 0.868 ""    C                  UNC_rs510… ""     
# 10 "CAST/EiJ"    CAST/EiJm42 (m)     0.07  0.792 0.944 C                 0.862 ""    C                  UNC_rs510… ""     
# 11 "PWK/PhJ"     PWK/PhJ (f)         0.056 0.71  0.95  C                 0.766 ""    C                  UNC_rs510… ""     
# 12 "PWK/PhJ"     PWK/PhJm175 (m)     0.075 0.795 0.94  C                 0.87  ""    C                  UNC_rs510… ""     
# 13 "WSB/EiJ"     WSB/EiJ (f)         0.576 0.269 0.278 T                 0.845 ""    T                  UNC_rs510… ""    
  
  
  # Generate a wide table of consensus as expected for output file
  recoded <- recoded_consensus_genotypes %>%
    dplyr::distinct(marker, strain, consensus_genotype) %>% 
    tidyr::pivot_wider(names_from = strain, values_from = consensus_genotype)
#   marker         `A/J` `C57BL/6J` `129S1/SvImJ` `NOD/ShiLtJ` `NZO/HlLtJ ` `CAST/EiJ` `PWK/PhJ` `WSB/EiJ`
#   <chr>          <chr> <chr>      <chr>         <chr>        <chr>        <chr>      <chr>     <chr>    
# 1 UNC_rs51041698 C     T          C             C            C            C          C         T        
  
  # Check for any founders that still segregate a genotype within the marker
  still_consensus <- recoded_consensus_genotypes %>%
    dplyr::group_by(strain, consensus_genotype) %>%
    dplyr::count() %>%
    dplyr::group_by(strain) %>%
    dplyr::count()
  
  # If there are still discrepancies (i.e. non-N genotypes segregating among samples), return the equivalent of the input data for downstream work
  if(2 %in% still_consensus$n){
    original_consensus <- suppressWarnings(data %>%
                                     dplyr::mutate(marker = mk) %>%
                                     dplyr::distinct(marker, strain, consensus_genotype) %>%
                                     tidyr::pivot_wider(names_from = strain, values_from = consensus_genotype))
    
    original_sample_calls <- suppressWarnings(data %>%
                                                dplyr::mutate(marker = mk) %>%
                                                dplyr::distinct(marker, sample, sample_genotype) %>%
                                                tidyr::pivot_wider(names_from = sample,
                                                                   values_from = sample_genotype))
    original_data <- data %>%
      dplyr::mutate(marker = mk,
                    recoded = "")
    
    return(list(original_consensus, original_sample_calls, original_data))
  } else{
    sample_new_consensus_calls <- recoded_consensus_genotypes %>%
                  dplyr::distinct(marker, sample, consensus_genotype) %>% 
                  tidyr::pivot_wider(names_from = sample, 
                                     values_from = consensus_genotype)
    return(list(recoded, sample_new_consensus_calls, recoded_consensus_genotypes))
  }
}


```

## Reading in reference genotypes and metadata

First I read in the reference sample genotypes, as well as marker annotations from an [analysis](https://github.com/kbroman/MUGAarrays) previously conducted by Karl Broman, Dan Gatti, and Belinda Cornes.

```{r Reading in reference genotypes and metadata}

## Reading in marker annotations fro Broman, Gatti, & Cornes analysis
pre_control_genotypes <- data.table::fread("../data/MUGA/vendu.dodata.csv", header = T)
samples <- unique(colnames(pre_control_genotypes)[-c(1:3)])
control_genotypes <- data.table::fread("../data/MUGA/vendu.dodata.csv", header = T, skip = 1)


tidyMUGAgenos <- function(smp){
    # print(smp)
    meta <- control_genotypes[,1:3]
    geno_info <- data.frame(control_genotypes)[,which(colnames(pre_control_genotypes) == smp)]
    if(ncol(geno_info > 8)){
      # B6 sample is exactly repeated in source data
      geno_info_1 <- geno_info[,1:8]
      tidy_geno_info <- cbind(meta, geno_info_1) %>%
        dplyr::mutate(sample = paste0(smp)) %>%
        `colnames<-`(c("snpID","Chromosome","Position","call","X","Y","gcScore","theta","r","xRaw","yRaw","sample"))
      return(tidy_geno_info)
      
    } else {
      tidy_geno_info <- cbind(meta, geno_info) %>%
        dplyr::mutate(sample = smp) %>%
        `colnames<-`(c("snpID","Chromosome","Position","call","X","Y","gcScore","theta","r","xRaw","yRaw","sample"))
      return(tidy_geno_info)  
    }
    
}
tidy_control_genotypes <- purrr::map(samples, tidyMUGAgenos) %>% 
  Reduce(rbind,.) %>%
  dplyr::rename(marker = snpID,
                genotype = call)
muga_metadata <- data.table::fread("../data/MUGA/muga_uwisc_v2.csv", header = T)
```

## Marker QC: Searching for missing genotype calls

We searched for probes where many mice are missing genotype calls.

```{r Markers with high "N" counts among reference samples}

## Calculating allele frequencies for each marker
control_allele_freqs <- tidy_control_genotypes %>%
  dplyr::select(sample, marker, genotype) %>%
  dplyr::group_by(marker, genotype) %>%
  dplyr::count() %>%
  # Result: number of genotype calls for each marker across all samples
  # i.e.
#    marker            genotype     n
#    <chr>             <chr>    <int>
#  1 backupJAX00000484 A           12
#  2 backupJAX00000484 G           21
#  3 backupJAX00000484 H           22
#  4 backupJAX00003592 A           14
#  5 backupJAX00003592 G           18
#  6 backupJAX00003592 H           23
#  7 backupJAX00004293 C           16
#  8 backupJAX00004293 H           24
#  9 backupJAX00004293 T           15
# 10 backupJAX00005508 A            8
  dplyr::ungroup() %>%
  dplyr::group_by(marker) %>%
  dplyr::mutate(freq = round(n/sum(n), 3),
                genotype = as.factor(genotype)) %>%
  # Result: allele frequency calls for each marker across all samples
  # i.e.
#    marker            genotype     n  freq
#    <chr>             <fct>    <int> <dbl>
#  1 backupJAX00000484 A           12 0.218
#  2 backupJAX00000484 G           21 0.382
#  3 backupJAX00000484 H           22 0.4  
#  4 backupJAX00003592 A           14 0.255
#  5 backupJAX00003592 G           18 0.327
#  6 backupJAX00003592 H           23 0.418
#  7 backupJAX00004293 C           16 0.291
#  8 backupJAX00004293 H           24 0.436
#  9 backupJAX00004293 T           15 0.273
# 10 backupJAX00005508 A            8 0.145
  dplyr::left_join(., muga_metadata)


## Filtering to markers with missing genotypes
no.calls <- control_allele_freqs %>%
  dplyr::ungroup() %>%
  dplyr::filter(genotype == "N") %>%
  tidyr::pivot_wider(names_from = genotype, 
                     values_from = n) %>%
  dplyr::select(marker, chr, bp_grcm39, freq) %>%
  dplyr::mutate(chr = as.factor(chr))


## Identifying markers with missing genotypes at a frequency higher than the 95th percentile of "N" frequencies across all markers
cutoff <- quantile(no.calls$freq, probs = seq(0,1,0.05))[[20]]
above.cutoff <- no.calls %>%
  dplyr::filter(freq > cutoff)
```

Of `r length(unique(as.factor(control_allele_freqs$marker)))` markers, `r nrow(no.calls)` failed to genotype at least one sample, and `r nrow(above.cutoff)` markers failed to genotype at least `r cutoff*100`% of samples.

```{r Plotting no calls, echo=FALSE}

# Returns a table of bad markers with all available metadata
above.cutoff %>%
  dplyr::left_join(.,muga_metadata) %>%
  dplyr::mutate(chr = as.factor(chr)) %>%
  dplyr::arrange(marker) %>%
  DT::datatable(., filter = "top", 
              escape = FALSE, 
              options = list(columnDefs = list(list(width = '20%', targets = c(8)))))


# Distribution of N frequencies across all markers. Dotted line indicates the 95th percentile of N frequencies (cutoff).
ggplot(no.calls, mapping = aes(x = freq)) + 
  geom_histogram(bins = 100) +
  scale_x_continuous(breaks = seq(0,1,0.1)) + 
  geom_vline(xintercept = cutoff, linetype = 2) + 
  QCtheme + 
  labs(x = "Fraction of mice with missing genotypes",
       y = "Number of markers")
```

## Sample QC

### Searching for samples with poor marker representation

In a similar fashion, we calculated the number of reference samples with missing genotypes. Repeated observations of samples/strains with identical names meant that genotype counts for each marker among them couldn't be grouped and tallied, so determining no-call frequency occurred column-wise. Mouse over individual samples to see the number of markers with missing genotypes for each sample.

```{r Reference samples with high missingness}

## Calculating the number of missing markers for each sample
n.calls.strains.df <- tidy_control_genotypes %>%
  dplyr::select(sample, marker, genotype) %>%
  dplyr::group_by(sample, genotype) %>%
  dplyr::count() %>%
  dplyr::filter(genotype == "N") %>%
  dplyr::ungroup() %>%
  dplyr::select(sample, n) %>%
  dplyr::rename(n.no.calls = n)
#    sample              n.no.calls
#    <chr>                    <int>
#  1 #1-m-9376 (m)              149
#  2 #2-m-9376 (m)              201
#  3 #3-m-9376 (m)              191
#  4 #4-m-9376 (m)              226
#  5 #5-m-9376 (m)              217
#  6 #6-m-9376 (m)              154
#  7 129S1/SvImJ (f)            176
#  8 129S1/SvImJm212 (m)        158
#  9 129xCASTf005 (f)           113
# 10 129xPWK 040F (f)           108


## Interactive plot of the number of missing genotypes for each sample.
sampleQC <- ggplot(n.calls.strains.df, 
                   mapping = aes(x = reorder(sample,n.no.calls), 
                                 y = n.no.calls,
                                 text = paste("Sample:", sample))) + 
  geom_point() +
  QCtheme + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) +
  labs(x = "Number of mice with missing genotypes",
       y = "Number of markers")
ggplotly(sampleQC, tooltip = c("text","y"))

```

From the sample QC plot, we can see that one of the NOD/ShiLtJ references samples is missing `r n.calls.strains.df[which(n.calls.strains.df$sample == "NOD/ShiLtJ-35335 (m)"),]$n.no.calls` genotypes, reducing our confidence in its use for consensus building. We exclude this sample in subsequent analyses.

### Validating sex of reference samples

We next validated the sexes of each sample using sex chromosome probe intensities. We paired up probe intensities, joined available metadata, and filtered down to only markers covering the X and Y chromosomes.

```{r Filtering to Chr X Markers}
## Bad samples
bad_samples <- c("NOD/ShiLtJ-35335 (m)")

## Reading in genotype intensities
long_intensities <- tidy_control_genotypes %>%
  dplyr::select(sample, marker, Chromosome, Position, genotype, X, Y, theta)

## Joining slimmer intensity files with marker metadata and reducing to markers on sex chromosomes
long_XY_intensities <- long_intensities %>%
  dplyr::left_join(., muga_metadata) %>%
  dplyr::filter(Chromosome %in% c("X","Y"),
                !sample %in% bad_samples)

# Expected output
#          marker Chromosome Position genotype     X     Y  chr bp_mm10 bp_grcm39   cM_cox strand snp unique unmapped
# 1: UNC200279739          X  4324915        H 0.745 1.560 <NA>      NA        NA       NA   <NA>  AG  FALSE    FALSE
# 2: UNC200000454          X  5080366        T 0.903 0.019    X 5503248   5415302 1.131211  minus  AC   TRUE    FALSE
# 3: UNC200001507          X  5282192        H 1.791 1.417 <NA>      NA        NA       NA   <NA>  AG  FALSE    FALSE
# 4: UNC200282646          X  5667495        A 0.446 0.010    X 6090377   6002431 1.406192   plus  AG   TRUE    FALSE
# 5: UNC200880603          X  5938298        G 0.016 0.517    X 6361180   6273234 1.533023  minus  TC   TRUE    FALSE
# 6: UNC200285015          X  6105555        A 0.998 0.026    X 6528437   6440491 1.611357   plus  AG   TRUE    FALSE
#                                                 probe strand_flipped
# 1: ATTCTTTGAATTTGTTCAGTGTCTCTTGTTAGGACTGTACTTTCATTTCT          FALSE
# 2: AGTGATACATACTCACATTCAGCTTCCAGTGTGATACTGCAGGGTGAAAC          FALSE
# 3: TATTTTAGTCTATTGTATAGTCCACCTTTCCCCTAGGCCATTGTAAATAC          FALSE
# 4: AGCAAGACATAATTTCCACATTACTAAGTCAATTAACGTGCAAATATGAC          FALSE
# 5: ATCTTGTTCAGATGTGTTATCTGGATAGTGCTGGCTTCACAGACTAAGTT          FALSE
# 6: GCAGCCTGCAAAACACCTTCCAAAACTACAAAAGCTGGCTAACAGAGAGC          FALSE

```

Then we flagged markers with high missingness across all samples, as well as samples with high missingness among all markers.

```{r Flagging "low-quality" markers and samples}

## Flagging markers and samples based on previous QC steps
flagged_XY_intensities <- long_XY_intensities %>%
  dplyr::mutate(marker_flag = dplyr::if_else(condition = marker %in% above.cutoff$marker,
                                             true = "FLAG",
                                             false = ""))
```

The first round of inferring predicted sexes used a rough search of the sample name for expected nomenclature convention, which includes a sex denotation.

```{r preliminary sex labeling and founder sample breakdown}

# Vector of founder strain names
loose_founder_strains <- c("A/J","C57BL/6J","129","NOD",
                           "NZO","CAST",    "PWK","WSB")

# Re-flag genotypes based on bad markers or bad samples.
# Inputs:
# 1) All sample genotypes
# 2) marker metadata
# 3) flag cutoff tables
genos.flagged <- tidy_control_genotypes %>%
  dplyr::left_join(., muga_metadata) %>%
  # Flagging markers and samples
  dplyr::mutate(marker_flag = dplyr::if_else(condition = marker %in% above.cutoff$marker,
                                             true = "FLAG",
                                             false = ""))

## First round of predicted sex inference
## Input: flagged XY intensities
prelim.predicted.sexes <- flagged_XY_intensities %>%
  dplyr::mutate(predicted.sex = dplyr::case_when(stringr::str_detect(string = sample, pattern = "(f)") == TRUE ~ "f",
                                                 stringr::str_detect(string = sample, pattern = "(m)") == TRUE ~ "m",
                                      TRUE ~ "unknown"))
## Output: flagged intensities with preliminary sex predictions and background assignments among F1 hybrids
#           sample       marker Chromosome Position genotype     X     Y  chr bp_mm10 bp_grcm39   cM_cox strand snp unique unmapped
# 1: #1-m-9376 (m) UNC200279739          X  4324915        H 0.745 1.560 <NA>      NA        NA       NA   <NA>  AG  FALSE    FALSE
# 2: #1-m-9376 (m) UNC200000454          X  5080366        T 0.903 0.019    X 5503248   5415302 1.131211  minus  AC   TRUE    FALSE
# 3: #1-m-9376 (m) UNC200001507          X  5282192        H 1.791 1.417 <NA>      NA        NA       NA   <NA>  AG  FALSE    FALSE
# 4: #1-m-9376 (m) UNC200282646          X  5667495        A 0.446 0.010    X 6090377   6002431 1.406192   plus  AG   TRUE    FALSE
# 5: #1-m-9376 (m) UNC200880603          X  5938298        G 0.016 0.517    X 6361180   6273234 1.533023  minus  TC   TRUE    FALSE
# 6: #1-m-9376 (m) UNC200285015          X  6105555        A 0.998 0.026    X 6528437   6440491 1.611357   plus  AG   TRUE    FALSE
#                                                 probe strand_flipped marker_flag predicted.sex
# 1: ATTCTTTGAATTTGTTCAGTGTCTCTTGTTAGGACTGTACTTTCATTTCT          FALSE                         m
# 2: AGTGATACATACTCACATTCAGCTTCCAGTGTGATACTGCAGGGTGAAAC          FALSE                         m
# 3: TATTTTAGTCTATTGTATAGTCCACCTTTCCCCTAGGCCATTGTAAATAC          FALSE                         m
# 4: AGCAAGACATAATTTCCACATTACTAAGTCAATTAACGTGCAAATATGAC          FALSE                         m
# 5: ATCTTGTTCAGATGTGTTATCTGGATAGTGCTGGCTTCACAGACTAAGTT          FALSE                         m
# 6: GCAGCCTGCAAAACACCTTCCAAAACTACAAAAGCTGGCTAACAGAGAGC          FALSE                         m



# Join the sample table with resex information with each sample's strain background from initial sex prediction.
# Inputs:
# 1) Sample metadata, including sex
# 2) Sample strain background
sample.meta <- prelim.predicted.sexes %>%
  dplyr::ungroup() %>%
  dplyr::distinct(sample, predicted.sex)
#           sample predicted.sex
# 1: #1-m-9376 (m)             m
# 2: #3-m-9376 (m)             m
# 3: #5-m-9376 (m)             m
# 4: #2-m-9376 (m)             m
# 5: #4-m-9376 (m)             m
# 6: #6-m-9376 (m)             m

# From the sample metadata, extract any sample derived from an CC/DO founder.
founder_samples <- sample.meta %>%
  dplyr::mutate(founder = case_when(str_detect(sample, loose_founder_strains[1]) == TRUE ~ "FOUNDER",
                                    str_detect(sample, loose_founder_strains[2]) == TRUE ~ "FOUNDER",
                                    str_detect(sample, loose_founder_strains[3]) == TRUE ~ "FOUNDER",
                                    str_detect(sample, loose_founder_strains[4]) == TRUE ~ "FOUNDER",
                                    str_detect(sample, loose_founder_strains[5]) == TRUE ~ "FOUNDER",
                                    str_detect(sample, loose_founder_strains[6]) == TRUE ~ "FOUNDER",
                                    str_detect(sample, loose_founder_strains[7]) == TRUE ~ "FOUNDER",
                                    str_detect(sample, loose_founder_strains[8]) == TRUE ~ "FOUNDER",
                                    TRUE ~ "NOT CC/DO Founder")) %>%
  dplyr::filter(founder == "FOUNDER")
#                 sample predicted.sex founder
# 1:             A/J (f)             f FOUNDER
# 2:         A/Jm111 (m)             m FOUNDER
# 3:        C57BL/6J (f)             f FOUNDER
# 4:     129S1/SvImJ (f)             f FOUNDER
# 5: 129S1/SvImJm212 (m)             m FOUNDER
# 6:         NOD/LtJ (f)             f FOUNDER


remaining_samples <- sample.meta %>%
  dplyr::filter(!sample %in% founder_samples$sample)
founder_letters <- LETTERS[1:8]
recoded_founder_samples <- remaining_samples %>%
  dplyr::mutate(code = str_sub(start = 1, end = 2, string = sample),
                dam = str_sub(start = 1, end = 1, string = code),
                sire = str_sub(start = 2, end = 2, string = code)) %>%
  dplyr::mutate(dam = case_when(dam == "A" ~ loose_founder_strains[1],
                                dam == "B" ~ loose_founder_strains[2],
                                dam == "C" ~ loose_founder_strains[3],
                                dam == "D" ~ loose_founder_strains[4],
                                dam == "E" ~ loose_founder_strains[5],
                                dam == "F" ~ loose_founder_strains[6],
                                dam == "G" ~ loose_founder_strains[7],
                                dam == "H" ~ loose_founder_strains[8]),
                sire = case_when(sire == "A" ~ loose_founder_strains[1],
                                 sire == "B" ~ loose_founder_strains[2],
                                 sire == "C" ~ loose_founder_strains[3],
                                 sire == "D" ~ loose_founder_strains[4],
                                 sire == "E" ~ loose_founder_strains[5],
                                 sire == "F" ~ loose_founder_strains[6],
                                 sire == "G" ~ loose_founder_strains[7],
                                 sire == "H" ~ loose_founder_strains[8]),
                founder = case_when(str_detect(dam, loose_founder_strains[1]) == TRUE ~ "FOUNDER",
                                    str_detect(dam, loose_founder_strains[2]) == TRUE ~ "FOUNDER",
                                    str_detect(dam, loose_founder_strains[3]) == TRUE ~ "FOUNDER",
                                    str_detect(dam, loose_founder_strains[4]) == TRUE ~ "FOUNDER",
                                    str_detect(dam, loose_founder_strains[5]) == TRUE ~ "FOUNDER",
                                    str_detect(dam, loose_founder_strains[6]) == TRUE ~ "FOUNDER",
                                    str_detect(dam, loose_founder_strains[7]) == TRUE ~ "FOUNDER",
                                    str_detect(dam, loose_founder_strains[8]) == TRUE ~ "FOUNDER",
                                    TRUE ~ "NOT CC/DO Founder"))



# Identify parental strains of founder samples
final_founder_samples <- founder_samples %>%
  tidyr::separate(sample, sep = "x", into = c("dam","sire"), remove = F) %>% 
  dplyr::mutate(dam = case_when(str_detect(dam, loose_founder_strains[1]) == TRUE ~ loose_founder_strains[1],
                                str_detect(dam, loose_founder_strains[2]) == TRUE ~ loose_founder_strains[2],
                                str_detect(dam, loose_founder_strains[3]) == TRUE ~ loose_founder_strains[3],
                                str_detect(dam, loose_founder_strains[4]) == TRUE ~ loose_founder_strains[4],
                                str_detect(dam, loose_founder_strains[5]) == TRUE ~ loose_founder_strains[5],
                                str_detect(dam, loose_founder_strains[6]) == TRUE ~ loose_founder_strains[6],
                                str_detect(dam, loose_founder_strains[7]) == TRUE ~ loose_founder_strains[7],
                                str_detect(dam, loose_founder_strains[8]) == TRUE ~ loose_founder_strains[8],
                                str_detect(dam, "AJ") == TRUE ~ loose_founder_strains[1],
                                str_detect(dam, "B6") == TRUE ~ loose_founder_strains[2],
                                TRUE ~ "NOT CC/DO Founder"),
                sire = case_when(str_detect(sire, loose_founder_strains[1]) == TRUE ~ loose_founder_strains[1],
                                str_detect(sire, loose_founder_strains[2]) == TRUE ~ loose_founder_strains[2],
                                str_detect(sire, loose_founder_strains[3]) == TRUE ~ loose_founder_strains[3],
                                str_detect(sire, loose_founder_strains[4]) == TRUE ~ loose_founder_strains[4],
                                str_detect(sire, loose_founder_strains[5]) == TRUE ~ loose_founder_strains[5],
                                str_detect(sire, loose_founder_strains[6]) == TRUE ~ loose_founder_strains[6],
                                str_detect(sire, loose_founder_strains[7]) == TRUE ~ loose_founder_strains[7],
                                str_detect(sire, loose_founder_strains[8]) == TRUE ~ loose_founder_strains[8],
                                str_detect(sire, "AJ") == TRUE ~ loose_founder_strains[1],
                                str_detect(sire, "B6") == TRUE ~ loose_founder_strains[2],
                                TRUE ~ "NOT CC/DO Founder")) %>%
  dplyr::bind_rows(., recoded_founder_samples) %>%
  dplyr::mutate(dam = as.factor(dam),
                sire = as.factor(sire)) %>%
  dplyr::filter(!is.na(dam)) %>%
  dplyr::select(-code) %>%
  dplyr::mutate(sire = if_else(sire == "NOT CC/DO Founder", dam, sire),
                bg = if_else(dam == sire, "INBRED", "CROSS"))

strict_founder_strains <- c("129S1/SvImJ","A/J","C57BL/6J","CAST/EiJ","NOD/ShiLtJ","NZO/HlLtJ","PWK/PhJ","WSB/EiJ")
levels(final_founder_samples$dam) <- strict_founder_strains
levels(final_founder_samples$sire)<- strict_founder_strains

#                 sample         dam        sire predicted.sex founder     bg
# 1:             A/J (f)         A/J         A/J             f FOUNDER INBRED
# 2:         A/Jm111 (m)         A/J         A/J             m FOUNDER INBRED
# 3:        C57BL/6J (f)    C57BL/6J    C57BL/6J             f FOUNDER INBRED
# 4:     129S1/SvImJ (f) 129S1/SvImJ 129S1/SvImJ             f FOUNDER INBRED
# 5: 129S1/SvImJm212 (m) 129S1/SvImJ 129S1/SvImJ             m FOUNDER INBRED
# 6:         NOD/LtJ (f)  NOD/ShiLtJ  NOD/ShiLtJ             f FOUNDER INBRED


# Count up samples for each founder and resulting cross and display a table
# Dam names = row names; Sire name = column names
founder_sample_table <- final_founder_samples %>%
  dplyr::group_by(dam,sire) %>%
  dplyr::count() %>%
  tidyr::pivot_wider(names_from = sire, values_from = n)
DT::datatable(founder_sample_table, escape = FALSE, 
              options = list(columnDefs = list(list(width = '20%', targets = c(8)))))

```

```{r Het rate for sexing}

XY_hetrate <- long_XY_intensities %>%
  # dplyr::right_join(., prelim.predicted.sexes, by = "sample") %>%
  dplyr::mutate(het = if_else(genotype == "H", "HET","NO_HET")) %>%
  dplyr::select(sample, marker, Chromosome, genotype, het) %>%
  dplyr::right_join(., prelim.predicted.sexes %>%
                      dplyr::select(sample, predicted.sex)) %>%
  dplyr::group_by(predicted.sex, Chromosome, het, sample) %>%
  dplyr::count() %>%
  tidyr::pivot_wider(names_from = het, values_from = n) %>%
  dplyr::mutate(het_rate = HET/(HET+NO_HET)) %>%
  dplyr::left_join(., final_founder_samples)
XY_hetrate_plot <- ggplot(XY_hetrate, mapping = aes(x = predicted.sex, y = het_rate, fill = bg, label = sample)) + 
  geom_jitter(shape = 21, width = 0.1) + 
  facet_grid(.~Chromosome)
ggplotly(XY_hetrate_plot)
```

```{r Predicted sex visualization}

# Input: Sex chromosome probe intensities for each marker with 1) marker metdata, 2) marker and sample flags, 3) background and sex predictions
Xchr.int <- prelim.predicted.sexes %>%
  dplyr::ungroup() %>%
  dplyr::filter(marker_flag != "FLAG",
                Chromosome == "X") %>%
  dplyr::mutate(x.chr.int = X + Y,
                theta = as.numeric(theta)) %>%
  dplyr::group_by(sample, predicted.sex) %>%
  dplyr::summarise(mean.x.chr.int = mean(x.chr.int),
                   mean.x = mean(X),
                   mean.theta = mean(theta))
# Expected output: Sample-averaged summed x- and y-channel probe intensities for all chromosome X markers. Note: replicated sample information collapses at this step. This is tolerable under the assumption that the samples with identical names are in fact duplicates of the same individual.

#   sample        predicted.sex mean.x.chr.int
#   <chr>         <chr>                  <dbl>
# 1 #1-m-9376 (m) m                       1.10
# 2 #2-m-9376 (m) m                       1.07
# 3 #3-m-9376 (m) m                       1.10
# 4 #4-m-9376 (m) m                       1.13
# 5 #5-m-9376 (m) m                       1.12
# 6 #6-m-9376 (m) m                       1.11


Ychr.int <- prelim.predicted.sexes %>%
  dplyr::ungroup() %>%
  dplyr::mutate(theta = as.numeric(theta)) %>%
  dplyr::filter(marker_flag != "FLAG",
                Chromosome == "Y") %>%
  dplyr::group_by(sample, predicted.sex) %>%
  dplyr::summarise(mean.y.int = mean(Y),
                   mean.theta = mean(theta))
# Expected output: Sample-averaged y-channel probe intensities for all chromosome Y markers. Note: replicated sample information collapses at this step. This is tolerable under the assumption that the samples with identical names are in fact duplicates of the same individual.

#   sample        predicted.sex mean.y.int
#   <chr>         <chr>              <dbl>
# 1 #1-m-9376 (m) m                  0.826
# 2 #2-m-9376 (m) m                  0.804
# 3 #3-m-9376 (m) m                  0.729
# 4 #4-m-9376 (m) m                  0.804
# 5 #5-m-9376 (m) m                  0.826
# 6 #6-m-9376 (m) m                  0.733


# Column binding the two intensities if the sample information matches
if(unique(Xchr.int$sample == Ychr.int$sample) == TRUE){
  sex.chr.intensities <- cbind(Xchr.int,Ychr.int$mean.y.int)
  colnames(sex.chr.intensities) <- c("sample","predicted.sex","sumxy_int","x_int","mean_theta","y_int")
}

# Interactive visualization of sex prediction results. Sample are colored according to predicted sex. "Unknown" samples are plotted black, and flagged/bad samples are triangles.
predicted.sex.plot.palettes <- sex.chr.intensities %>%
  dplyr::ungroup() %>%
  dplyr::distinct(sample, predicted.sex) %>%
  dplyr::mutate(predicted.sex.palette = dplyr::case_when(predicted.sex == "f" ~ "#5856b7",
                                                         predicted.sex == "m" ~ "#eeb868",
                                                         predicted.sex == "unknown" ~ "black"))
predicted.sex.palette <- predicted.sex.plot.palettes$predicted.sex.palette
names(predicted.sex.palette) <- predicted.sex.plot.palettes$predicted.sex
mean.x.intensities.by.sex.plot <- ggplot(sex.chr.intensities, 
                                         mapping = aes(x = sumxy_int, 
                                                       y = y_int, 
                                                       colour = predicted.sex,
                                                       text = sample)) + 
  geom_point() + 
  scale_colour_manual(values = predicted.sex.palette) + 
  # facet_grid(.~chr) +
  QCtheme
ggplotly(mean.x.intensities.by.sex.plot, 
         tooltip = c("text","label"))
```

Combining plots of heterozygosity rates of X and Y chromosomes and the sex chromosome probe intensities, we observed four samples that were originally classified as females that were likely male samples, including one named "NODxPWKm004 (f)" displaying proper sample nomenclature for a male sample. We have manually assigned these samples the appropriate sex designation.

```{r Re-assigning sex}
final.predicted.sex <- prelim.predicted.sexes %>%
  dplyr::mutate(inferred.sex = if_else(condition = sample %in% c("PWK/PhJ (f)",
                                                                 "NODxPWKm004 (f)",
                                                                 "C57BL/6J (f)",
                                                                 "WSB/EiJ (f)"), 
                                       true = "m", 
                                       false = predicted.sex),
                resexed = if_else(condition = sample %in% c("PWK/PhJ (f)",
                                                                 "NODxPWKm004 (f)",
                                                                 "C57BL/6J (f)",
                                                                 "WSB/EiJ (f)"), 
                                       true = T, 
                                       false = F))


## Taking the first marker as a sample and tabulating the number of samples for each predicted sex
predicted.sex.table <- final.predicted.sex %>%
  dplyr::filter(marker %in% unique(prelim.predicted.sexes$marker)[1]) %>%
  dplyr::select(sample, inferred.sex) %>%
  dplyr::group_by(inferred.sex) %>%
  dplyr::count()

```

This captured `r predicted.sex.table[which(predicted.sex.table$inferred.sex == "f"),2]$n` female samples, `r predicted.sex.table[which(predicted.sex.table$inferred.sex == "m"),2]$n` male samples, leaving `r predicted.sex.table[which(predicted.sex.table$inferred.sex == "unknown"),2]$n` samples of unknown predicted sex from nomenclature alone.

```{r Inferred sex visualization}
Xchr.int <- final.predicted.sex %>%
  dplyr::ungroup() %>%
  dplyr::filter(marker_flag != "FLAG",
                Chromosome == "X") %>%
  dplyr::mutate(x.chr.int = X + Y,
                theta = as.numeric(theta)) %>%
  dplyr::group_by(sample, inferred.sex) %>%
  dplyr::summarise(mean.x.chr.int = mean(x.chr.int),
                   mean.x = mean(X),
                   mean.theta = mean(theta))


Ychr.int <- final.predicted.sex %>%
  dplyr::ungroup() %>%
  dplyr::mutate(theta = as.numeric(theta)) %>%
  dplyr::filter(marker_flag != "FLAG",
                Chromosome == "Y") %>%
  dplyr::group_by(sample, inferred.sex) %>%
  dplyr::summarise(mean.y.int = mean(Y),
                   mean.theta = mean(theta))



# Column binding the two intensities if the sample information matches
if(unique(Xchr.int$sample == Ychr.int$sample) == TRUE){
  sex.chr.intensities <- cbind(Xchr.int,Ychr.int$mean.y.int)
  colnames(sex.chr.intensities) <- c("sample","inferred.sex","sumxy_int","x_int","mean_theta","y_int")
}

# Interactive visualization of sex prediction results. Sample are colored according to predicted sex. "Unknown" samples are plotted black, and flagged/bad samples are triangles.
final.sex.plot.palettes <- sex.chr.intensities %>%
  dplyr::ungroup() %>%
  dplyr::distinct(sample, inferred.sex) %>%
  dplyr::mutate(final.sex.palette = dplyr::case_when(inferred.sex == "f" ~ "#5856b7",
                                                     inferred.sex == "m" ~ "#eeb868",
                                                     inferred.sex == "unknown" ~ "black"))
final.sex.palette <- final.sex.plot.palettes$final.sex.palette
names(predicted.sex.palette) <- final.sex.plot.palettes$inferred.sex
mean.x.intensities.by.sex.plot <- ggplot(sex.chr.intensities %>%
                                           dplyr::left_join(., final.predicted.sex %>% 
                                                              dplyr::distinct(sample, inferred.sex, resexed)), 
                                         mapping = aes(x = sumxy_int, 
                                                       y = y_int, 
                                                       colour = inferred.sex,
                                                       fill = resexed,
                                                       text = sample)) + 
  geom_point() + 
  scale_colour_manual(values = predicted.sex.palette) + 
  scale_fill_manual(values = c("black","white")) +
  # facet_grid(.~chr) +
  QCtheme
ggplotly(mean.x.intensities.by.sex.plot, 
         tooltip = c("text","label"))
```


### Validating reference sample genetic backgrounds

A key component of sample QC for our purposes is knowing that markers that we expect to deliver the consensus genotype (*i.e.* in a cross) actually provide us the correct strain information and allow us to correctly infer haplotypes.


```{r founder sample dendrogram, fig.width=10, fig.height=10}
sample.predicted.sexes.df <- final.predicted.sex %>%
  dplyr::distinct(sample, inferred.sex)

# Join all genotypes to founder-derived samples, filter away bad markers, and reduce down to unique rows for each sample and marker genotype
# Inputs: 
# 1) Founder sample metadata (colnames(all_founder_samples_parents) = "sample"        "dam"           "sire"          "bad_sample"    "inferred.sex"  "resexed"       "bg"            "founder"      "weird.founder"
# 2) All sample genotypes with flag information
founder_sample_genos <- final_founder_samples %>%
  dplyr::left_join(., sample.predicted.sexes.df) %>%
  dplyr::select(-founder) %>%
  dplyr::left_join(.,genos.flagged) %>%
  dplyr::filter(marker_flag != "FLAG",
                genotype != "N") %>%
  dplyr::distinct(sample, marker, genotype, inferred.sex, dam, sire)


# Creating a wide genotype table to compute the distance matrix for the dendrogram, filtering out the markers with multiple genotype calls per sample.
wide_founder_sample_genos <- founder_sample_genos %>%
  dplyr::select(sample, marker, genotype) %>%
  tidyr::pivot_wider(names_from = marker, values_from = genotype)

# Genotype calls at this point are still in letter form (i.e. A, T, or H for het). In order to calculate the distance matrix, we had to recode each marker's genotype information into 0, 1 for hets or 2. This process is applied column-wise.
recoded_wide_sample_genos <- suppressWarnings(data.frame(apply(wide_founder_sample_genos[,2:ncol(wide_founder_sample_genos)], 2, recodeCalls)))
dend.labels <- wide_founder_sample_genos %>%
  dplyr::select(sample) %>%
  dplyr::left_join(.,final_founder_samples %>%
                     dplyr::select(sample, dam, sire) %>%
                     dplyr::mutate(dam = as.character(dam),
                                   sire = as.character(sire))) %>%
  dplyr::mutate(bg = if_else(condition = dam == sire, 
                             true = paste0(dam,"_",sample), 
                             false = paste0(dam,"x",sire,"_",sample)))
rownames(recoded_wide_sample_genos) <- dend.labels$bg

# Scaling the genotype matrix, then calculating euclidean distance between all samples
dd <- dist(scale(recoded_wide_sample_genos), method = "euclidean")
hc <- hclust(dd, method = "ward.D2")

# Plotting sample distances as a dendrogram
ndendcolors <- 3
dend_colors = c(brewer.pal(ndendcolors,"Paired")) 
clus8 = cutree(hc, ndendcolors)
plot(as.phylo(hc), type = "f", cex = 0.8, tip.color = dend_colors[clus8],
     no.margin = T, label.offset = 1, edge.width = 0.5)

```

From here we curated a set of genotypes for each CC/DO founder strain that were fixed across replicate samples from that strain. 

```{r generate founder consensus calls}
for(f in strict_founder_strains){
  
  print(paste("Generating Calls for",f))
  
  # Pulling the samples and genotypes for each CC/DO founder strain
  founder.geno.array <- final_founder_samples %>%
    dplyr::filter(dam == f,
                  sire == f) %>%
    # Attach all genotypes
    dplyr::left_join(.,genos.flagged, by = "sample") %>%
    # Use only high-quality markers
    dplyr::filter(marker_flag != "FLAG")


  # Count the number of unique allele calls for each marker
  founder.allele.counts <- founder.geno.array %>%
    dplyr::group_by(marker, genotype) %>%
    dplyr::count()
  
  # Collect markers which have identical genotypes across samples from the same founder
  complete_founder_genos <- founder.allele.counts %>%
    dplyr::filter(n == max(founder.allele.counts$n)) %>%
    dplyr::select(-n) %>%
    `colnames<-`(c("marker",f))

  # Assign these calls to a founder object
  assign(paste0("Calls_",f), complete_founder_genos)

}
```

The genotypes for intersecting markers between two strains were combined ("crossed") to form predicted genotypes for each F1 hybrid of CC/DO founders. Then, the genotypes of each CC/DO founder F1 hybrid were compared directly to what was predicted, and the concordance shown below is the proportion of markers of each individual that match this prediction.

```{r determine founder strains with missing consensus calls}

# Build a list of founder consensus genotypes for good markers
founder_consensus_calls <- list(`Calls_A/J`, `Calls_C57BL/6J`, `Calls_129S1/SvImJ`, `Calls_NOD/ShiLtJ`,
                                `Calls_NZO/HlLtJ`, `Calls_CAST/EiJ`, `Calls_PWK/PhJ`, `Calls_WSB/EiJ`)

# Generate a data frame with good markers as the sole column
good_markers <- genos.flagged %>%
  dplyr::distinct(marker, marker_flag) %>%
  dplyr::filter(marker_flag != "FLAG")

# Loop through the exisitng consensus calls and filter down to good markers
filtered_consensus_calls <- purrr::map(founder_consensus_calls, 
                                       function(x){
                                         x %>% 
                                           dplyr::filter(marker %in% good_markers$marker)
                                         }) %>%
  Reduce(full_join, .)

# Filter samples down to inbred strains and attach a proper strain name column
founder_sample_metadata <- final_founder_samples %>%
  dplyr::left_join(., sample.predicted.sexes.df) %>%
  dplyr::mutate(dam = as.character(dam),
                sire = as.character(sire),
                strain = if_else(dam == sire, true = dam, false = "CROSS"),
                resexed = if_else(predicted.sex != inferred.sex, true = "TRUE", false = "FALSE")) %>% 
  dplyr::select(-inferred.sex) %>%
  dplyr::filter(bg == "INBRED", 
                strain %in% strict_founder_strains)
#                 sample         dam        sire predicted.sex founder     bg      strain resexed
# 1:             A/J (f)         A/J         A/J             f FOUNDER INBRED         A/J   FALSE
# 2:         A/Jm111 (m)         A/J         A/J             m FOUNDER INBRED         A/J   FALSE
# 3:        C57BL/6J (f)    C57BL/6J    C57BL/6J             f FOUNDER INBRED    C57BL/6J    TRUE
# 4:     129S1/SvImJ (f) 129S1/SvImJ 129S1/SvImJ             f FOUNDER INBRED 129S1/SvImJ   FALSE
# 5: 129S1/SvImJm212 (m) 129S1/SvImJ 129S1/SvImJ             m FOUNDER INBRED 129S1/SvImJ   FALSE
# 6:         NOD/LtJ (f)  NOD/ShiLtJ  NOD/ShiLtJ             f FOUNDER INBRED  NOD/ShiLtJ   FALSE


# Create column index for intensity data tables
founder_samples_for_ints <- c("marker",founder_sample_metadata$sample)
founder_intensities <- founder_sample_metadata %>%
  dplyr::left_join(., long_intensities)

# 
# # Identify consensus calls that have complete data across founders
# founder_consensus_complete <- filtered_consensus_calls[complete.cases(filtered_consensus_calls),]
# # Identify consensus calls that have DO NOT have complete data across founders (i.e. maybe some sort of discrepancy among samples contributing to that founder)
# founder_consensus_incomplete <- filtered_consensus_calls[!complete.cases(filtered_consensus_calls),]

```



```{r fig.width=10, fig.height=5}
# Assemble a list of predicted genotypes for F1s by combining each founder-specific dataframe of calls

# for(f in strict_founder_strains){
#   clean_founder_con <- clean_founder_consensus_genotypes %>%
#     dplyr::ungroup() %>%
#     dplyr::select(marker, f)
#   assign(paste0("Clean_Calls_",f), clean_founder_con)
# }


# First form a list of dams that comprise each F1 cross type
dams <- data.frame(tidyr::expand_grid(strict_founder_strains, strict_founder_strains, .name_repair = "minimal")) %>%
  `colnames<-`(c("dams","sires")) %>%
  # Select crosses between strains
  # filter(dams != sires) %>%
  dplyr::select(dams) %>%
  as.list()
# Loop through the list of cross types and pull in genotype call objects
dam_calls <- list()
for(i in 1:length(dams$dams)){
  dam_calls[[i]] <- get(ls(pattern = paste0("Calls_",dams$dams[i])))
}

# Do the same for the sires
sires <- data.frame(tidyr::expand_grid(strict_founder_strains, strict_founder_strains, .name_repair = "minimal")) %>%
  `colnames<-`(c("dams","sires")) %>%
  # filter(dams != sires) %>%
  dplyr::select(sires) %>%
  as.list()
sire_calls <- list()
for(i in 1:length(sires$sires)){
  sire_calls[[i]] <- get(ls(pattern = paste0("Calls_",sires$sires[i])))
}

# Compare the predicted genotypes (from consensus calls) to the actual genotypes of each sample
# founder_background_QC(dam = dam_calls[[2]], sire = sire_calls[[2]])
bg_QC <- purrr::map2(dam_calls, sire_calls, founder_background_QC)

# Keep outputs from the QC that are lists; if QC wasn't performed for a given background, the output was a character vector warning
founder_background_QC_tr <- bg_QC %>%
  purrr::keep(., is.list) %>%
  # Instead of having 64 elements of lists of two, have two lists of 64:
  # 1) All good genotypes from each cross with concordance values
  # 2) All concordance summaries for each cross
  purrr::transpose(.)

# Bind together all concordance summaries
founder_concordance_df <- Reduce(rbind, founder_background_QC_tr[[2]])
# If all markers for a given chromosome type were either concordant or discordant, NAs are returned
# This step assigns those NA values a 0
founder_concordance_df[is.na(founder_concordance_df)] <- 0
# Form concordance as a percentage
founder_concordance_df_2 <- founder_concordance_df %>%
  dplyr::mutate(concordance = MATCH/(MATCH + `NO MATCH`)) %>%
  dplyr::mutate(dam = gsub(dam, pattern = "[.]", replacement = "/"),
                sire = gsub(sire, pattern = "[.]", replacement = "/"))
founder_concordance_df_2$alt_chr <- factor(founder_concordance_df_2$alt_chr,
                                           levels = c("Autosome","X","Y","M","Other"))
founder_concordance_df_3 <- founder_concordance_df_2 %>%
  dplyr::filter(alt_chr == "Autosome")
founder_palette <- qtl2::CCcolors
names(founder_palette) <- strict_founder_strains[c(2,3,1,5,6,4,7,8)]
founder_palette_2 <- founder_palette

concordance_plot <- ggplot(founder_concordance_df_3, mapping = aes(x = dam, y = concordance, color = dam, fill = sire)) + 
  geom_jitter(shape = 21, width = 0.25) +
  scale_fill_manual(values = founder_palette_2) +
  scale_colour_manual(values = founder_palette_2) +
  ylim(c(0.5,1.05)) + 
  labs(x = "Dam Founder Strain",
       y = "Autosomal Genotype Concordance") + 
  QCtheme
ggplotly(concordance_plot)

```

## Writing reference files

The list of output file types following QC is as follows:

-   Genotype file; rows = markers, columns = samples

-   Probe intensity file; rows = markers, columns = samples

-   Sample metadata; columns = sample, strain, sex

Each file type is generated for:

-   All good samples

-   Eight CC/DO founder strains

```{r summarize marker and samples, echo=FALSE}
# Categorize genotypes based on flags and consensus status
marker_categories <- genos.flagged %>%
  dplyr::select(marker, marker_flag) %>%
  dplyr::distinct()

# Filter down to good markers for all samples
good_markers <- marker_categories %>%
  dplyr::filter(marker_flag == "")

# Filter down to good samples
good_samples_df <- tidy_control_genotypes %>%
  dplyr::filter(sample != bad_samples) %>%
  dplyr::distinct(sample)
good_samples <- good_samples_df$sample
```

In total, `r nrow(good_markers)` markers and `r length(good_samples)-1` samples passed the QC steps we imposed, and wrote these genotype data and metadata to new reference files.

```{r output files for all samples, eval=FALSE, include=FALSE}

# Generate genotype files for all good samples and all good markers
reference_genos_all_samples <- tidy_control_genotypes %>%
  dplyr::select(marker, genotype, sample) %>%
  dplyr::filter(marker %in% good_markers$marker,
                sample %in% good_samples) %>%
  tidyr::pivot_wider(names_from = sample, values_from = genotype)


# All Reference Sample Intensities
reference_xints_all_samples <- tidy_control_genotypes %>%
  dplyr::select(marker, X, sample) %>%
  dplyr::filter(marker %in% good_markers$marker,
                sample %in% good_samples) %>%
  tidyr::pivot_wider(names_from = sample, values_from = X)

reference_yints_all_samples <- tidy_control_genotypes %>%
  dplyr::select(marker, Y, sample) %>%
  dplyr::filter(marker %in% good_markers$marker,
                sample %in% good_samples) %>%
  tidyr::pivot_wider(names_from = sample, values_from = Y)

# Founder consensus genotypes
final_founder_consensus_genotypes <- filtered_consensus_calls
final_founder_consensus_genotypes[is.na(final_founder_consensus_genotypes)] <- "N"

# All sample metadata
pre_metadata <- n.calls.strains.df %>%
  dplyr::left_join(.,final.predicted.sex %>% 
                   dplyr::select(sample, inferred.sex, resexed)) %>%
  dplyr::distinct() %>%
  dplyr::mutate(bad_sample = if_else(sample %in% bad_samples, true = "BAD SAMPLE", false = "")) %>%
  dplyr::mutate(predicted.sex = dplyr::case_when(stringr::str_detect(string = sample, pattern = "(f)") == TRUE ~ "f",
                                                 stringr::str_detect(string = sample, pattern = "(m)") == TRUE ~ "m",
                                      TRUE ~ "unknown"),
                inferred.sex = dplyr::if_else(is.na(inferred.sex), true = predicted.sex, false = inferred.sex)) %>%
  dplyr::rename(sex = inferred.sex) %>%
  dplyr::select(-predicted.sex, -n.no.calls)

strain_assignment <- final_founder_samples %>%
  dplyr::ungroup() %>%
  dplyr::distinct(sample, dam, sire) %>%
  dplyr::mutate(dam = as.character(dam),
                # dam = gsub(dam, pattern = " ", replacement = ""),
                sire = as.character(sire),
                # sire = gsub(sire, pattern = " ", replacement = ""),
                strain = if_else(dam == sire, 
                                 true = dam, 
                                 false = paste0("(",dam,"x",sire,")F1"))) %>%
  dplyr::left_join(pre_metadata,.) %>%
  dplyr::select(sample, sex, resexed, strain)


founder_sample_metadata_conc <- founder_concordance_df_3 %>%
  dplyr::left_join(., pre_metadata) %>%
  dplyr::left_join(., strain_assignment) %>% 
  dplyr::ungroup() %>%
  dplyr::select(sample, strain, sex, dam, sire, concordance) %>%
  dplyr::mutate(dam = case_when(dam == "A/J" ~ "A",
                                dam == "C57BL/6J" ~ "B",
                                dam == "129S1/SvImJ" ~ "C",
                                dam == "NOD/ShiLtJ" ~ "D",
                                dam == "NZO/HILtJ" ~ "E",
                                dam == "CAST/EiJ" ~ "F",
                                dam == "PWK/PhJ" ~ "G",
                                dam == "WSB/EiJ" ~ "H"),
                sire = case_when(sire == "A/J" ~ "A",
                                sire == "C57BL/6J" ~ "B",
                                sire == "129S1/SvImJ" ~ "C",
                                sire == "NOD/ShiLtJ" ~ "D",
                                sire == "NZO/HILtJ" ~ "E",
                                sire == "CAST/EiJ" ~ "F",
                                sire == "PWK/PhJ" ~ "G",
                                sire == "WSB/EiJ" ~ "H")) %>%
  tidyr::unite("letter", dam:sire, sep = "")

# Founder Sample Intensities
founder_mean_ints <- tidy_control_genotypes %>%
  dplyr::select(marker, sample, X, Y) %>%
  dplyr::filter(marker %in% good_markers$marker,
                sample %in% final_founder_samples$sample) %>%
  dplyr::right_join(., final_founder_samples %>%
                      dplyr::filter(bg == "INBRED")) %>%
  dplyr::left_join(., founder_sample_metadata) %>%
  dplyr::group_by(marker, strain) %>%
  dplyr::summarise(x_int = mean(X),
                   y_int = mean(Y))

founder_xints <- founder_mean_ints %>%
  dplyr::select(marker, strain, x_int) %>%
  tidyr::pivot_wider(names_from = strain, values_from = x_int)

founder_yints <- founder_mean_ints %>%
  dplyr::select(marker, strain, y_int) %>%
  tidyr::pivot_wider(names_from = strain, values_from = y_int)


dir.create("../output", showWarnings = F)
dir.create("../output/MUGA", showWarnings = F)

if(file.exists("../output/MUGA/MUGA_genotypes.csv.gz") == "FALSE"){
  write.csv(reference_genos_all_samples, file = "../output/MUGA/MUGA_genotypes.csv")
  system("gzip ../output/MUGA/MUGA_genotypes.csv")
}
if(file.exists("../output/MUGA/MUGA_x_intensities.csv.gz") == "FALSE"){
  write.csv(reference_xints_all_samples, file = "../output/MUGA/MUGA_x_intensities.csv")
  system("gzip ../output/MUGA/MUGA_x_intensities.csv")
}
if(file.exists("../output/MUGA/MUGA_y_intensities.csv.gz") == "FALSE"){
  write.csv(reference_yints_all_samples, file = "../output/MUGA/MUGA_y_intensities.csv")
  system("gzip ../output/MUGA/MUGA_y_intensities.csv")
  
}
if(file.exists("../output/MUGA/MUGA_sample_metadata.csv") == "FALSE"){
  write.csv(strain_assignment, file = "../output/MUGA/MUGA_sample_metadata.csv")
}

if(file.exists("../output/MUGA/MUGA_founder_consensus_genotypes.csv.gz") == "FALSE"){
  write.csv(final_founder_consensus_genotypes, file = "../output/MUGA/MUGA_founder_consensus_genotypes.csv")
  system("gzip ../output/MUGA/MUGA_founder_consensus_genotypes.csv")
}
if(file.exists("../output/MUGA/MUGA_founder_mean_x_intensities.csv.gz") == "FALSE"){
  write.csv(founder_xints, file = "../output/MUGA/MUGA_founder_mean_x_intensities.csv")
  system("gzip ../output/MUGA/MUGA_founder_mean_x_intensities.csv")
}
if(file.exists("../output/MUGA/MUGA_founder_mean_y_intensities.csv.gz") == "FALSE"){
  write.csv(founder_yints, file = "../output/MUGA/MUGA_founder_mean_y_intensities.csv")
  system("gzip ../output/MUGA/MUGA_founder_mean_y_intensities.csv")
}
if(file.exists("../output/MUGA/MUGA_founder_metadata.csv") == "FALSE"){
  write.csv(founder_sample_metadata_conc, file = "../output/MUGA/MUGA_founder_metadata.csv")
}


```
